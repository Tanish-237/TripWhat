import type { Itinerary, DayPlan, TimeSlot, Activity } from '../types/itinerary';

/**
 * Parse markdown itinerary into structured data
 * Handles the format generated by the backend
 */
export function parseItineraryFromMarkdown(markdown: string): Itinerary | null {
  try {
    // Extract title and duration
    const titleMatch = markdown.match(/# üó∫Ô∏è (\d+)-Day (.+?) Itinerary/);
    if (!titleMatch) return null;

    const duration = parseInt(titleMatch[1]);
    const destination = titleMatch[2];

    // Extract days
    const days: DayPlan[] = [];
    const dayRegex = /## üìÖ Day (\d+): (.+?)\n([\s\S]*?)(?=## üìÖ Day \d+:|---\n\n‚ú®|$)/g;
    
    let dayMatch;
    while ((dayMatch = dayRegex.exec(markdown)) !== null) {
      const dayNumber = parseInt(dayMatch[1]);
      const dayTitle = dayMatch[2];
      const dayContent = dayMatch[3];

      const timeSlots = parseTimeSlots(dayContent, dayNumber);

      days.push({
        dayNumber,
        title: dayTitle,
        timeSlots,
      });
    }

    return {
      id: `itinerary-${Date.now()}`,
      tripMetadata: {
        destination,
        duration,
      },
      days,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
  } catch (error) {
    console.error('Failed to parse itinerary:', error);
    return null;
  }
}

function parseTimeSlots(dayContent: string, dayNumber: number): TimeSlot[] {
  const timeSlots: TimeSlot[] = [];
  
  // Match time slot headers and their activities
  const slotRegex = /### (‚òÄÔ∏è|üåÜ|üåô|‚ú®) (Morning|Afternoon|Evening|Night) \((.+?)\)\n([\s\S]*?)(?=###|$)/g;
  
  let slotMatch;
  while ((slotMatch = slotRegex.exec(dayContent)) !== null) {
    const period = slotMatch[2].toLowerCase() as TimeSlot['period'];
    const timeRange = slotMatch[3]; // e.g., "09:00-12:00"
    const [startTime, endTime] = timeRange.split('-');
    const slotContent = slotMatch[4];

    const activities = parseActivities(slotContent, dayNumber);

    if (activities.length > 0) {
      timeSlots.push({
        period,
        startTime: startTime.trim(),
        endTime: endTime.trim(),
        activities,
      });
    }
  }

  return timeSlots;
}

function parseActivities(slotContent: string, dayNumber: number): Activity[] {
  const activities: Activity[] = [];
  
  // Match activity blocks
  const activityRegex = /\*\*(\d+)\. (.+?)\*\*\n([\s\S]*?)(?=\n\*\*\d+\.|$)/g;
  
  let activityMatch;
  while ((activityMatch = activityRegex.exec(slotContent)) !== null) {
    const activityNumber = parseInt(activityMatch[1]);
    const name = activityMatch[2];
    const details = activityMatch[3];

    // Extract metadata
    const duration = extractField(details, '‚è±Ô∏è');
    const cost = extractField(details, 'üí∞');
    const category = extractField(details, 'üè∑Ô∏è');
    const rating = extractRating(details);

    activities.push({
      id: `activity-${dayNumber}-${activityNumber}-${Date.now()}`,
      name,
      location: {
        lat: 0, // Will be updated from backend eventually
        lon: 0,
      },
      duration: duration || '1-2h',
      estimatedCost: cost,
      category: category || 'attraction',
      rating,
    });
  }

  return activities;
}

function extractField(text: string, emoji: string): string | undefined {
  const regex = new RegExp(`${emoji}\\s*(.+?)\\n`);
  const match = text.match(regex);
  return match ? match[1].trim() : undefined;
}

function extractRating(text: string): number | undefined {
  const match = text.match(/‚≠ê\s*(\d+)\/7/);
  return match ? parseInt(match[1]) : undefined;
}

/**
 * Check if a message contains an itinerary
 */
export function containsItinerary(message: string): boolean {
  return message.includes('# üó∫Ô∏è') && 
         message.includes('-Day') && 
         message.includes('Itinerary');
}
